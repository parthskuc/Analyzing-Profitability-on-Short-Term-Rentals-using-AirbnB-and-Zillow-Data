---
title: "Airbnb and Zillow Data Challenge"
output:
  html_document:
    toc: true
    code_folding: "hide"
    toc_float:
      collapsed: true
      smooth_scroll: true
    theme: united
    highlight: tango
---


## Problem Statement: 
#### To analyze the given data to identify the zipcodes in New York that are worth investing for most profit on short term rentals.

## Data Available:
For this purpose, publicly available data from Zillow and AirBnB were used.

1)	Cost data: Zillow provides us an estimate of value for two-bedroom properties.
2)	Revenue data: AirBnB is the medium through which the investor plans to lease out their investment property.


## Assumptions:

1)	The investor will pay for the property in cash (i.e. no mortgage/interest rate will need to be accounted for).
2)	The time value of money discount rate is 0% (i.e. $1 today is worth the same 100 years from now).
3)	All properties and all square feet within each locale can be assumed to be homogeneous (i.e. a 1000 square foot   property in a locale such as Bronx or Manhattan generates twice the revenue and costs twice as much as anyother   500 square foot property within that same locale.)
4) The room types 'Entire house' and 'Private room' are considered the same. The price given for the stay at the    property is considered the total price irrespective of the room type.
5) Availablity for next 365 days is a considered as the metric for occupancy. Lesser than availablity , higher the   occupancy.
6) Occupancy rate is calculated by subtracting the total available days by total number of days in year and         dividing it by 365.
7) Revenue is calculated o basis of price per night. It is assumed the security deposit is returned to the  customer once they checkout and the cleaning fees is spent in cleaning the property.
8) Number of reviews is considered a positvie trait for any property. Higher count of reviews shows more engagement.
9) Availability within 30, 60 ,90 and 365 days are considered highly similar(as shown later). Yearly availability is taken into analysis because tourism is seasonal in nature.


## Key metrics:
For this purpose of getting the top zipcodes there are some key metrics that I'll base my analysis on. Some of these metrics are assumptions whereas the others are researched based on information on property evaluation.

1) Reviews: Number of reviews on a property depict a lot about the property. More number of reviews mean the property has been booked more often as compared to properties with fewer number of reviews. A zipcode that comprises of properties with more reviews has high engagemnent with users and more probable to be booked in future.

2) Occupancy Rate: It is the percentage of occupancy of the property in a given month/year. Greather the availability , lesser is the occupancy. More occupancy will A property that is occupied 365 days in a year has a occupancy rate of 100% whereas a property.

3) Annual Return: It is the revenue generated from the property on a yearly basis. For the purpose of this analysis, the annual return is calculated by multiplying the price per night, yearly occupancy rate and 365 days.
(price/night* yearly_occupancy * 365)

4) Rent Ratio: It's the annual rent collected from the property divided by the price of the property. The higher the rent ratio the better. It means either that the property is bought at a cheap rate or the rent is higher. In either of these cases, the ivestor is at gain.

5) Break Even Time: Break-even time represents the amount of time it takes for an investment to make back its original cost. It is caluclated here by dividing the original cost of the proerty by annual rent generated by the property. But since the rent for the property will not be same every year, an increase of 10% in the rent genrated yearly is considered. So lesser is the break even time, the better it is for the investor since after the break event time, most of the revenue will be a profit for the investor and properties with high break even time will take longer to even out the expenes.

## Process Followed:

1) Package Loading: Getting the required packages.
1) Data Loading: Cost and Revenue file were loaded. They contain 262 and 106 rows respectively.
2) Data Preparation: Cost and Revenue datasets are handled separately in an attempt to enrich the data quality for      exploratory data analysis.
   a) Missing value and Duplicate values check: Data is checked for missing values and duplicate values.Columns with       missing value percentage > 50% is dropped.
   b) Data Cleaning: Dropping columns not required for analysis. Dropping the dollar sign from price and changing the       format to numeric type.
3) Merging the datasets: Merging with the revenue file to get property cost of 2 bedroom apartments on the zipcodes.
4) Calculating Key Metrics: Creating key metrics and adding them to the dataframe as columns.
5) Exploratory Data Analysis: Visualizaing the data by plots and graphs to study and understand the key metrices and strengthen the analysis.
Revenue and Cost data were joined based on zipcodes and final data set contains 25 zipcodes to choose from,expanding over 4 major neighbourhoods - Manhattan, Queens, Brooklyn and Staten Island.

## Key Findings:

1) Most of zipcodes in Manhattan and Brooklyn have higher property cost. Since these zipcodes are also popular in terms of tourism they make some excellent choice for investment.

2) Price and Availablity are not inveresely proportional. Customers are not hestitant to pay higher price ahead of time. The company can capitalize this behavior into their pricing scheme.

3) Staten Island and Queens Neighbourhood have limited choices but it also gets fewer guests. In case the company wants to diversify, they should pick the top zips from different neighbourhoods to minimize risk.


## Top Zipcodes:
1) 11434
2) 10003
3) 10013
4) 11201
5) 11217 and 10014


## Conclusion:
1) Zipcode 11434 comes at first, It fits 3 out of 5 metrics.
2) Zipcode 10003 gets the second place , it also fits 3 out of 5 metrics.
3) Zipcode 10013 is also very profound, it is on the top on 2 metrics. With a higher rent ratio and annual return it can prove to be very profitable.
4) 11201 comes in 2nd and 3rd position for Occupancy percentage and  break even time.
5) 11217 and 10014 are also good choices since both of these perform good in 2 metrics.

## Initial Setup:

### Package Loading
Loading the packages and installing them in case they are not present already.
```{r echo=TRUE,  results='hide', message=FALSE}

## Check for package versions and update them accordingly
##https://gist.github.com/benmarwick/5054846
list.of.packages <- c("tidyverse", "DataExplorer","corrplot","caret","nnet","readr","tidyr","ggplot2","plotly","kableExtra") #
new.packages <- list.of.packages[!(list.of.packages %in% installed.packages()[,"Package"])]
if(length(new.packages)) install.packages(new.packages) 
lapply(new.packages, require, character.only=T)

library(naniar)
library(tidyverse)
library(DataExplorer)
library(corrplot)
library(caret)
library(nnet)
library(readr)
library(tidyr)
library(ggplot2)
library(plotly)
library(kableExtra)



```

## Loading Data:

### Loading the Cost(zillow) and Revenue(airbnb) datasets
```{r echo=TRUE, message=FALSE , error=FALSE, warning=FALSE,results='hide'}
zillow=read_csv('Zip_Zhvi_2bedroom.csv')
head(zillow)

airbnb=read_csv('listings.csv')

```

## Data Preparation

### Cost Data
```{r echo=TRUE, message=FALSE,warning=FALSE,error=FALSE}
kable(head(zillow))  %>% kable_styling(bootstrap_options = c("striped", "hover", "responsive")) %>% scroll_box(width = "100%", height = "250px")

```
### Filtering cost data
```{r echo=TRUE, message=FALSE,warning=FALSE,error=FALSE, results='hide'}
#selecting the desired city
filter_city <- 'New York' 

#selecting the desired number of bedrooms
filter_bedroom <- 2

start_date <- '2014'
end_date <- '2017'
head(zillow)
```


Filtering only the rows that have City as New York. Checking the column years for null values and dropping the columns with missing values

```{r echo=TRUE, message=FALSE,results='hide'}
zillow<- zillow %>% filter(City==filter_city) %>% select(RegionID,RegionName,City,State,Metro,CountyName,SizeRank,'1996-04':'2017-06') 
# Filtering zillow data based on parameter filter_city
head(zillow)
colSums(is.na(zillow))
cond1 <- sapply(zillow, function(col) sum(is.na(col)) == 0)
zillow<-zillow[,cond1,drop=T]
```

Removing the year 2007 columns since it is starting with mid year

```{r echo=TRUE, message=FALSE,results='hide'}
zillow<-zillow[,-c(8:14)]
zillow<-zillow[,-c(3:7)]

```

```{r include=FALSE}
summary(zillow)
```

### Restructuring the data.
We have data for every months from 2008 to 2017. It means there are (12*10) columns of price data for the past 10 years, which is cumbersome to process and analyse. Median is chosen as opposed to Mean to guard against large outlier values which may lead to bias in analysis. 

Process:
1) Calculate median price of each individual zipcodes across the years from 2008 to 2017. 
2) Asign the median price calculated to the respective zipcodes.

```{r}
zillow<-gather(zillow,key='year',value='price','2008-01':'2017-06')
zillow$year<-substr(zillow$year,1,4)
zillow<-zillow[,-1]
zillow2<-zillow %>% group_by(RegionName,year) %>% mutate(median_price = median(price)) %>% ungroup()
zillow2<-zillow2[,-3]
zillow2 %>% arrange(RegionName)
```
```{r include=FALSE}
#checking for duplicate values
zillow2<-zillow2[!duplicated(zillow2[1:3]),]
```



### Median price over the past 10 years (2008-2017)
We now have median price for every zipcode for every year from 2008 to 2017 i.e for 25 zipcodes and 10 years.Plotting the distribuition of median price over the past 10 years (2008-2017) to see the trend in the real estate market.

```{r fig.width=7, fig.height=5, message=FALSE, warning=FALSE, error=FALSE}
zillow2$RegionName <- as.factor(zillow2$RegionName)
zipcodemedianprice<-ggplot(zillow2,aes(
x = year,
  y = median_price,
  group = RegionName,
  colour = RegionName
  )) + geom_line() + geom_point() + scale_y_continuous(labels = scales::comma)+theme(legend.title = element_blank(),panel.grid.major = element_blank(),panel.grid.minor = element_blank(),panel.background = element_blank(),axis.line = element_line(colour = "black")) 
ggplotly(zipcodemedianprice)
```

As seen from the plot above, the prices of houses are fluctuating for some zipcodes. While for other zipcodes it has been consistent moslty. So it's better not consider these years for the analysis and start with 2014 to get less variability in prices. Dropped the years from 2008 to 2013.
```{r echo=TRUE, message=FALSE,results='hide',error=FALSE,warning=FALSE}
zillow2<-spread(zillow2,key='year',value='median_price')
zillow2<-zillow2 %>% select(RegionName,start_date:end_date)
head(zillow2)
```


### Predicting median price for 2019

The dataset has latest prices for year 2017, but for the analysis in 2019 I'll try to predict the median for the year 2019. The approach is to calculate the growth for every consecutive year and then take an average of it. And this average growth per year is used to calculate the prices for year 2019.

The columns year1,year2 and year3 shows the relative increase in the prices of house from the previous year. 
The avg_growth column is the average of year1,year2 and year3. 
2018 and 2019 shows the predicted prices for year 2018 and 2019.
```{r}
zillow2<- zillow2 %>% mutate(year1 = `2015`/`2014`) %>%
                   mutate(year2 = `2016`/`2015`) %>%
                   mutate(year3 = `2017`/`2016`) %>%
                   mutate(avg_growth = (year1+year2+year3)/3) %>%
                   mutate(`2018` = avg_growth * `2017`) %>%
                   mutate(`2019` = avg_growth * `2018`)

zillow2<-zillow2[,-c(2:10)]
zillow2<-gather(zillow2,key='year',value='price', '2019')
head(zillow2)
```
Removing the columns we don't need and renaming the column 2019 to price, which is the predicted price for year 2019. This is the final cleansed cost data that is used further in this analysis.

### Median price of properties in 2019

Plotting median price(predicted) of properties in 2019 by zipcodes.
```{r fig.width=7, fig.height=5, message=FALSE,error=FALSE,warning=FALSE}
medianpriceplot<-ggplot(zillow2 %>% arrange(desc(price)) %>% mutate(zipcode=factor(RegionName, levels=RegionName)),aes(x = as.factor(RegionName),y = price)) + geom_col(fill="#339999") + scale_y_continuous(labels = scales::comma) +labs(x = "Zipcodes", y = "Price of properties")+theme(axis.text.x = element_text(angle = 90, hjust = 1),legend.title = element_blank(),panel.grid.major = element_blank(),panel.grid.minor = element_blank(),panel.background = element_blank(),axis.line = element_line(colour = "black")) 
ggplotly(medianpriceplot)
```
<strong>Zipcodes 10013,10014,10011,10003 and 10023<strong> are the top 5 costliest in terms of property unlike <strong>10303,10304,10306,10312 and 10314<strong> which are the cheapest zipcodes to buy properties in New York City.

## Data Preparation
### Revenue data

```{r}
kable(head(airbnb))  %>% kable_styling(bootstrap_options = c("striped", "hover", "responsive")) %>% scroll_box(width = "100%", height = "250px")
```
Revenue is a large dataset with 48000 rows and 106 columns. Before checking for missing values 
Removing the columns in the airbnb dataset that has information related to the hosts, url and other data points not related to our analysis.

### Filtering revenue data
Removing column names specific to hosts and some other columns not necessary for the analysis.
```{r echo=TRUE, message=FALSE,results='hide'}
pattern <-
  colnames(airbnb %>% dplyr::select(starts_with("require"),starts_with("host"),starts_with("calendar"),
  ends_with("url"),ends_with("nights")))

airbnb <- airbnb[,!(names(airbnb) %in% pattern)]
dropCol <-
  c(
  'scrape_id',
  'name',
  'summary',
  'description',
  'neighborhood_overview',
  'notes',
  'transit',
  'access',
  'interaction',
  'house_rules',
  'street',
  'market',
  'smart_location',
  'country_code',
  'CountyName',
  'bed_type',
  'amenities',
  'guests_included',
  'extra_people',
  'review_scores_communication',
  'review_scores_checkin',
  'review_scores_cleanliness',
  'review_scores_value',
  'reviews_per_month',
  'instant_bookable',
  'is_location_exact'
  )

airbnb <- airbnb[,!(names(airbnb) %in% dropCol)]

```


Checking for missing values and dropping the columns with more than 50% missing values and some other not so useful columns
```{r echo=TRUE, message=FALSE,results='hide'}
colSums(is.na(airbnb))*100/nrow(airbnb)

airbnb <- airbnb[,-c(3,4,5,6,9,11,22,23,26,27,28,34,35,36,38,39,40,41,42,43,44,45,46,47)]
```
Dropping the columns with more than 50% missing values and some other not so useful columns

### Finalizing the Revenue data
```{r}
dim(airbnb)
```
We now have 23 columns in the revenue data.

## Merging the datasets
Merging the cost(zillow) datset with revenue(airbnb) dataset on zipcodes and checking for duplicates and missing values in our final dataset.

```{r}
final_data <- merge(airbnb, zillow2, by.x = "zipcode",by.y = "RegionName")
final_data <- final_data %>% filter(bedrooms==filter_bedroom)


final_data<-final_data[!duplicated(final_data[1:25]),]
final_data<-final_data %>% 
  rename(
    cost = price.x,
    revenue = price.y
    )

```

Creating a copy for the final data. In case of any discrepencies later during the analysis, there's no need to read and load the data again. Final data can be loaded and continued.

```{r echo=TRUE, message=FALSE,results='hide'}
airbnb <- final_data
head(airbnb)
colSums(is.na(airbnb))
```
Creating a function to clean the price columns. This fucntion removes any spaces and/or $ signs then converts type to numeric from character.

```{r}
clean_price <- function(df, col)
{
  data<-df[,which(colnames(df)==col)]
  clean_data <- str_replace_all(data, fixed("$"), "")
  clean_data <-as.numeric(str_replace_all(clean_data, fixed(","), ""))
  return(clean_data)
}

airbnb$cost <-clean_price(airbnb,"cost")


```

### Final clean revenue data
This is the final cleansed dataset that will be used henceforth. Here's a summary of the dataset.

```{r}
summary(airbnb)
```

```{r}
kable(head(airbnb))  %>% kable_styling(bootstrap_options = c("striped", "hover", "responsive")) %>% scroll_box(width = "100%", height = "250px")
```

## Exploratory Data Analysis

### Plotting the distribution of missing variables in our final data.

```{r fig.width=7, fig.height=5}
missingvariables<-gg_miss_var(airbnb, show_pct = TRUE) + labs(x = "Variables", y = "Percentage of missing values")
ggplotly(missingvariables)
```


Most of the property in our analysis will deal with Apartment. It does makes sense though looking at properties in New York City, the apartment count would be a lot larger than other house types.

### Checking the number of properties by neighbourhood

```{r fig.width=9, fig.height=5}
countbyneighbourhood<-ggplot(airbnb,aes(fct_infreq(neighbourhood_group_cleansed)))+geom_bar(fill="#339999")+labs(x = "Neighbourhood", y = "Number of Properties") +theme(legend.title = element_blank(),panel.grid.major = element_blank(),panel.grid.minor = element_blank(),panel.background = element_blank(),axis.line = element_line(colour = "black")) 
ggplotly(countbyneighbourhood)
```

### Checking the price per night of properties by neighbourhood.

```{r fig.width=9, fig.height=5}
by_neighbourhood <- airbnb %>% group_by(neighbourhood_group_cleansed) %>%summarize(mean_price_x = mean(cost)) %>% ungroup()

by_neighbourhoodplot<-ggplot(by_neighbourhood ,aes(x=neighbourhood_group_cleansed,y=mean_price_x))+geom_col(fill="#339999") + labs(x = "Neighbourhood", y = "Price per night of Properties")+scale_y_continuous(labels = scales::comma)+theme(legend.title = element_blank(),panel.grid.major = element_blank(),panel.grid.minor = element_blank(),panel.background = element_blank(),axis.line = element_line(colour = "black"))
ggplotly(by_neighbourhoodplot)
```


### Checking the number of properties by zipcodes.
```{r fig.width=9, fig.height=5}

numberbyZipcode<-ggplot(airbnb,aes(fct_infreq(as.factor(zipcode))))+geom_bar(fill="#339999")+labs(x = "zipcodes", y = "Number of Properties")+theme(axis.text.x = element_text(angle = 90, hjust = 1),legend.title = element_blank(),panel.grid.major = element_blank(),panel.grid.minor = element_blank(),panel.background = element_blank(),axis.line = element_line(colour = "black"))

ggplotly(numberbyZipcode)
```

Some zipcodes have just 1, 2 or 3 properties, which is a small number for analysis. So these zipcodes would not be conisdered for the analysis.
Dropping the zipcodes with less than 10 properties
```{r}
final_zipcodes<-airbnb %>% group_by(zipcode) %>% summarize(count=n()) %>% filter(count>10) %>% ungroup()
airbnb<-subset(airbnb, zipcode %in% final_zipcodes$zipcode)

```

### Number of properties by type

Plotting the number of properties by their type. We see that mostly the property in our datset are Apartments.

```{r fig.width=7, fig.height=5, echo=FALSE}

propertytypecount<-ggplot(airbnb,aes(fct_infreq(property_type))) +geom_bar(fill="#339999")+labs( x="Property type", y="count") + theme(axis.text.x = element_text(angle = 90, hjust = 1),legend.title = element_blank(),panel.grid.major = element_blank(),panel.grid.minor = element_blank(),panel.background = element_blank(),axis.line = element_line(colour = "black")) 
ggplotly(propertytypecount)
```

### Price distribution of properties

Checking the price distribution of properties according to property types

```{r fig.width=9, fig.height=8}
pricebyproperty<-ggplot(airbnb, aes(x=property_type, y=cost, fill = as.factor(zipcode),color=as.factor(zipcode))) + scale_y_continuous(labels = scales::comma) + geom_point(aes(size=cost)) + 
geom_smooth(method="loess", se=F) + labs( x="Property type", y="Price per night") + theme(axis.text.x = element_text(angle = 90, hjust = 1),legend.title = element_blank(),panel.grid.major = element_blank(),panel.grid.minor = element_blank(),panel.background = element_blank(),axis.line = element_line(colour = "black"))
ggplotly(pricebyproperty)
```
It is evident that apartments are costlier than any other type of property and apartments in zipcodes 11217 and 10003 are the cosltiest for a night.
Checking the variation in price per night of the properties across the zipcodes along with zipcodes.We see there are some properties in Manhattan which are way above the avergae prices.

```{r fig.width=9, fig.height=5 ,warning=FALSE }
by_neighbourhood_zip_price <- airbnb %>% group_by(neighbourhood_group_cleansed,zipcode) %>%summarize(mean_price_x = mean(cost)) %>% ungroup()

ggplot(airbnb ,aes(x=as.factor(zipcode),y=cost,fill = as.factor(neighbourhood_group_cleansed)))+geom_boxplot() + labs(x = "Zipcodes", y = "Price Per Night") + scale_y_continuous(limits = quantile(airbnb$cost, c(0, 0.99))) +theme(axis.text.x = element_text(angle = 90, hjust = 1))+theme(axis.text.x = element_text(angle = 90, hjust = 1),legend.title = element_blank(),panel.grid.major = element_blank(),panel.grid.minor = element_blank(),panel.background = element_blank(),axis.line = element_line(colour = "black"))
```

It is noticeable that there are a lot of outliers in the price per night.Specially the zipcodes 10013 and 10003 have the costilest staying prices.

### Visualizing the price per night of the properties by zipcodes

```{r fig.width=9, fig.height=5}
zipcodes_price <- airbnb %>% group_by(zipcode) %>%summarize(mean_price_x = mean(cost)) %>% ungroup()

byzipcodes_price<-ggplot(zipcodes_price %>% arrange(desc(mean_price_x)) %>%  mutate(zipcode=factor(zipcode, levels=zipcode)),aes(x=as.factor(zipcode),y=mean_price_x))+geom_col(fill="#339999") + labs(x = "Zipcodes", y = "Mean price per night")+scale_y_continuous(labels = scales::comma)+theme(axis.text.x = element_text(angle = 90, hjust = 1),legend.title = element_blank(),panel.grid.major = element_blank(),panel.grid.minor = element_blank(),panel.background = element_blank(),axis.line = element_line(colour = "black"))
ggplotly(byzipcodes_price)

```


## Computing and analysing key metrics

### 1) Number of reviews

This column that has the count of reviews on a property is already present in our dataset.
```{r echo=TRUE, message=FALSE,results='hide'}
airbnb$number_of_reviews
```

### Checking the average number of reviews of the properties by zipcode.

```{r fig.width=9, fig.height=5}
zipcodes_review <- airbnb %>% group_by(zipcode) %>%summarize(average_review_count = mean(number_of_reviews)) %>% ungroup()

byzipcodes_review<-ggplot(zipcodes_review %>% arrange(desc(average_review_count)) %>%  mutate(zipcode=factor(zipcode, levels=zipcode)) ,aes(x=as.factor(zipcode),y=average_review_count))+geom_col(fill="#339999") + labs(x = "Zipcodes", y = "Average number of reviews")+scale_y_continuous(labels = scales::comma)+theme(axis.text.x = element_text(angle = 90, hjust = 1),legend.title = element_blank(),panel.grid.major = element_blank(),panel.grid.minor = element_blank(),panel.background = element_blank(),axis.line = element_line(colour = "black"))
ggplotly(byzipcodes_review)
```
The top zipcodes based on number of reviews are **11434,11215,11231,10305 and 10003.**


### 2) Availability and Occupancy Percentage

### Availabiity 

Availabiity of a property should be balanced. Less availability means the property is in high demand and is good for the property owner but higher availability means the property is not being booked and is a negative sign. Higher availability or lower occupancy  can be attributed to many reasons, such as 
1) High prices
2) Lesser/No tourist attractions
3) High crime rates

We have 30, 60, 90 and 365 days availability. All of these can be used for analysis. It's important to check how these variables corelate to each other.
```{r}
corCols <- airbnb[,c("availability_30","availability_60","availability_90","availability_365","number_of_reviews","cost","revenue")]
res<-cor(corCols)
corrplot(res, type = "upper", order = "hclust", 
         tl.col = "black", tl.srt = 45)
```

For the purpose of this study, yearly avaialbility (availability_365) is a better choice as it shows the bigger picture and being highly correlated with other variables, it will complement our analysis.
```{r include=FALSE}
airbnb[which(airbnb$occupancy_rt_year==0),]
```

### Occupancy Percentage

Occupancy is the opposite of availability. Higher the occupancy the better it is for the property owners and the investors. Higher occupancy in properties is a good sign and properties in these areas will bring in more profits.

Calculating the occupancy rate explanation: 
Yearly occupancy rate is calculated by subtracting the number of available days by 365 and dividing it by 365.
e.g. A property available for 100 days, means it is occupied for 265 days. so the occupancy percentage is 265*100/365= 72.6%. 

Properites with 0% occupancy rates have been assigned extremely small values to avoid interference in calculating annual return.
```{r}
airbnb<-airbnb %>% group_by(zipcode) %>% 
  mutate(occupancy_rt_30=(30-ifelse(availability_30==30,1,availability_30))*100/30,
occupancy_rt_60=(60-ifelse(availability_60==60,1,availability_60))*100/60, occupancy_rt_90=(90-ifelse(availability_90==90,1,availability_90))*100/90, occupancy_rt_year=(365-ifelse(availability_365==365,1,availability_365))*100/365) %>% 
  ungroup()

```


### Yearly occupancy percentage by price per night

```{r fig.width=9, fig.height=7}
OccupancyPrice <- airbnb %>% group_by(zipcode) %>% summarise(mean_price=mean(cost),mean_occupancy=mean(occupancy_rt_year)) 

byOccupancyPrice<-ggplot(OccupancyPrice,aes(x=mean_occupancy, y=mean_price)) + geom_point(aes(col=as.factor(zipcode), size=mean_price)) +labs(x="Occupancy", y="Price per night", shape="Price", colour= "Neighbourhood")+theme(axis.text.x = element_text(angle = 90, hjust = 1),legend.title = element_blank(),panel.grid.major = element_blank(),panel.grid.minor = element_blank(),panel.background = element_blank(),axis.line = element_line(colour = "black"))
ggplotly(byOccupancyPrice)
```
This establishes the claim that lower prices doesn't prove higher occupancy. People are ready to pay higher prices for poperties. But people prefer not to go too high with the prices as zipcodes with not too pricey properties have the highest occupancy.

The highly occupied zipcodes are **11217, 11201, 10021, 11231, 10014 and 10025.**

### Yearly Occupancy percentage of properties by zipcodes.

```{r fig.width=9, fig.height=5}
zipcodes_occ <- airbnb %>% group_by(zipcode) %>%summarize(mean_occupancy_rate = mean(occupancy_rt_year)) %>% ungroup()

byzipcodes_occ<-ggplot(zipcodes_occ %>% arrange(desc(mean_occupancy_rate)) %>%  mutate(zipcode=factor(zipcode, levels=zipcode)),aes(x=as.factor(zipcode),y=mean_occupancy_rate))+geom_col(fill="#339999") + labs(x = "Zipcodes", y = "Occupancy percentage")+scale_y_continuous(labels = scales::comma)+theme(axis.text.x = element_text(angle = 90, hjust = 1),legend.title = element_blank(),panel.grid.major = element_blank(),panel.grid.minor = element_blank(),panel.background = element_blank(),axis.line = element_line(colour = "black"))
ggplotly(byzipcodes_occ)
```

Zipcodes **11217,11201,11434, 10021 and 11231** have the highest yearly occupancy percentages.


### 3) Rent Ratio:
 Rent ratio is the measure of price of the property divided by the gross annual rent collected. Higher the rent ratio the better it is. A higher rent ratio suggests 2 things.
 1) Either the property was bought at a cheaper price.
 2) Or, the rent of the property is higher
In either of these cases the investor is at profit. It is an important factor to be kept in mind while buying a property.

```{r}
airbnb<-airbnb %>% group_by(zipcode) %>% mutate(rent_ratio=revenue/(cost*30*12)) %>% ungroup()
```

### Checking the rent ratio by zipcodes.


```{r fig.width=9, fig.height=5}
zipcodes_rent_ratio <- airbnb %>% group_by(zipcode) %>%summarize(mean_rent_ratio = round(mean(rent_ratio)),0) %>% ungroup()

by_zipcodes_rent_ratio <-ggplot(zipcodes_rent_ratio %>% arrange(desc(mean_rent_ratio)) %>%  mutate(zipcode=factor(zipcode, levels=zipcode)),aes(x=as.factor(zipcode),y=mean_rent_ratio))+geom_col(fill="#339999") + labs(x = "Zipcodes", y = "rent ratio")+scale_y_continuous(labels = scales::comma)+theme(axis.text.x = element_text(angle = 90, hjust = 1),legend.title = element_blank(),panel.grid.major = element_blank(),panel.grid.minor = element_blank(),panel.background = element_blank(),axis.line = element_line(colour = "black"))
ggplotly(by_zipcodes_rent_ratio)
```
Rent ratio is the highest for properties in zipcodes **10013,10014,10021,10128,10003.**

### 4) Annual Return or Return on Investment
Annual Return is the revenue generated from the property on a yearly basis. For the purpose of this analysis, the annual return is calculated by multiplying the price per night, yearly occupancy rate and 365 days.
**(price/night x yearly_occupancy x 365)**.  Higher the annual return, higher is the profit.


```{r echo=TRUE, message=FALSE,results='hide'}
airbnb<-airbnb %>% group_by(zipcode) %>% 
  mutate(annual_return=(cost*occupancy_rt_year*365)/100) %>% ungroup()
airbnb[which(airbnb$annual_return==0),]
```


### Annual return by zipcodes
 

```{r fig.width=9, fig.height=5}
zipcodes_return <- airbnb %>% group_by(zipcode) %>%summarize(mean_return = mean(annual_return)) %>% ungroup()

by_zipcodes_return<-ggplot(zipcodes_return %>% arrange(desc(mean_return)) %>%  mutate(zipcode=factor(zipcode, levels=zipcode)),aes(x=as.factor(zipcode),y=mean_return))+geom_col(fill="#339999") + labs(x = "Zipcodes", y = "Average annual return / Return on investment")+scale_y_continuous(labels = scales::comma)+ theme(axis.text.x = element_text(angle = 90, hjust = 1),legend.title = element_blank(),panel.grid.major = element_blank(),panel.grid.minor = element_blank(),panel.background = element_blank(),axis.line = element_line(colour = "black"))

ggplotly(by_zipcodes_return)
```
The zipcodes **10013,10011,10014,10003 and 10036** performs really good in this aspect.

### 5) Break even time
Break-even time represents the amount of time it takes for an investment to make back its original cost. It is caluclated here by dividing the original cost of the proerty by annual rent generated by the property. But since the rent for the property will not be same every year, an increase of 10% in the rent genrated yearly is considered.

Explanation: A property that was bought for 100,000 and generates an annual return(in 2019) of $20,000. The annual return will increase by 10% every year i.e in 2020 it will be 22,000 and 24,200 in 2021. Basically we multiply the price of current year by 1.1 to calculate the annual return next year.

The break even time for this property will be the year when total annual return collected will be equal to the original cost of property. i.e (100000/20000+22000+24200+26620+29282) ~ approx 4.5 years. So lesser is the break even time, the better it is for the investor. After the break event time, most of the revenue will be a profit for the investor.

### Creating function to calculate break even time of property and Calculating the break even time for the dataset.

```{r echo=TRUE, message=FALSE,results='hide'}

get_break_even_time <- function(df)
{
  break_even_time<-c()
  for (i in 1:nrow(df))
  {
year<-0
a_return<-airbnb$annual_return[i]
property_price<-airbnb$revenue[i]

while (property_price>a_return) 
{
  year=year+1
  a_return=a_return*1.1
}
  
  break_even_time[i]<-year
  }
  df$break_even_time<-break_even_time
  return(df)
}

airbnb<-get_break_even_time(airbnb)
```


### Visualizing the average break even times by zipcodes
```{r fig.width=9, fig.height=7}
Breakeventime <- airbnb %>% group_by(zipcode) %>% summarise(mean_break_even_time=mean(break_even_time)) 

byBreakeventime<-ggplot(Breakeventime %>% arrange(mean_break_even_time) %>%  
  mutate(zipcode=factor(zipcode, levels=zipcode)),aes(x=as.factor(zipcode), y=mean_break_even_time)) + geom_bar(stat = 'Identity',fill="#339999") +labs(x="Zipcodes", y="Break even time in years", shape="Price", colour= "Neighbourhood")+theme(axis.text.x = element_text(angle = 90, hjust = 1),legend.title = element_blank(),panel.grid.major = element_blank(),panel.grid.minor = element_blank(),panel.background = element_blank(),axis.line = element_line(colour = "black"))
ggplotly(byBreakeventime)

```

Final data set with added columns
```{r}
kable(head(airbnb))  %>% kable_styling(bootstrap_options = c("striped", "hover", "responsive")) %>% scroll_box(width = "100%", height = "250px")
```


Zipcodes **11434,10305,11201,11217 and 10025** have the lowest break even times. 

## Conclusion and Future Steps:

### Evaluation :

The zipcodes were analysed on the key metrics as described above and the top 5 zipcodes suggested by each of these metrics are as follows:

Reviews  | Occupancy  | Rent Ratio | Annual Return | Break even time
-------- | ---------- | ---------- | ------------- | ---------------
11434    |   11217    |   10013    |    10013      |     11434
11215    |   11201    |   10014    |    10011      |     10305
11231    |   11434    |   10021    |    10014      |     11201
10305    |   10021    |   10128    |    10003      |     11217
10003    |   11231    |   10003    |    10036      |     10025


We'll take the zipcodes that managed to make it to 2 or more metrics.

Top Zipcodes  | 
------------- | -------------
11434         | 
10003         | 
10013         |
11201         |
11217 & 10014 |

Preference has been given to those zipcodes which appear in 3 metrics. Rent ratio and Annual return has been preffered over occupancy percentage. So above mentioned are the possible suggested zipcodes for investments. However, it is necessary to discuss with the firm as to what types of risk they are willing to take.


### Conclusion:
1) Zipcode 11434 comes at first, It fits 3 out of 5 metrics.
2) Zipcode 10003 gets the second place , it also fits 3 out of 5 metrics.
3) Zipcode 10013 is also very profound, it is on the top on 2 metrics. With a higher rent ratio and annual return it can prove to be very profitable.
4) 11201 comes in 2nd and 3rd position for Occupancy percentage and  break even time.
5) 11217 and 10014 are also good choices since both of these perform good in 2 metrics.



### Future Steps:

1) Time series forecastiing techniques like ARIMA can be used for better and accurate prediction of cost of property at a future date.
2) Price per night are taken constant throughout the year, but ususally, the prices aren't stable and so they fluctuate depending on the time of the year. 
3) Text Analytics / Sentiment Analytics would open insights about other metrics that drive customer to book an airbnb property such as neighborhood descriptions, property descriptions and reviews.

